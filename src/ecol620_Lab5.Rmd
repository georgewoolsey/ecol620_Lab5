---
title: "Lab 5 - Spatial Dependence"
subtitle: "ECOL 620 - Applications in Landscape Ecology"
author: "George Woolsey"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: true
    toc_float: true
    # code_folding: hide
editor_options: 
  chunk_output_type: console
knit: (function(inputFile, encoding){ 
    out_dir <- '../';
    rmarkdown::render(inputFile, encoding = encoding, output_file=file.path(dirname(inputFile), out_dir, 'index.html'));
    file.copy(from = "..//index.html", to = '..///data//lab5_george_woolsey.html', overwrite = TRUE)
  })
  
---

# Setup

```{r, include=FALSE, warning=F, message=F}
# knit options
knitr::opts_chunk$set(
  echo = TRUE
  , warning = FALSE
  , message = FALSE
  # , results='hide'
  , fig.width = 10
  , fig.height = 7
)
```

```{r, eval=T}
# bread-and-butter
library(tidyverse)
library(lubridate)
library(viridis)
library(scales)
library(latex2exp)
# visualization
library(kableExtra)
library(ggtext)
# spatial analysis
library(terra)
library(pgirmess) #for simple correlograms
library(ncf)  #for spline correlograms
library(spdep)  #for general correlograms
library(gstat)  #for variograms/kriging
# set seed
set.seed(11)
```

# Rules
1. Using the provided R Markdown template, answer all questions and show your R code where necessary. Note, some questions are just plain text written answers.
2. Complete your assignment using the R markdown file and submit individual assignments to Canvas. Knit your script and submit an .html file on Canvas. Please use  the following naming convention: lab5_firstname_lastname.html (ex. lab5_kyle_horton.html).  Note, we will not grade labs in any other format.

```{r, include=FALSE, eval=FALSE}
not just trying to figure out the spatial arrangement of cactus, but trying to fill out surface of height across landscape

Moran's I is a spatial pearson's correlation (-1 to 1) of metric with itself. how correlated are values of metric with itself over geographic distances...after identify distance at which correlation is not significant (near 0), then "thin" data to that distance

Semivariogram - variance of metric is low at close distances (b/c values are similar) but higher at further distances because the variance is due to factors other than spatial dependence
emperical semivariogram is based on values of variance at specific points (range/distance). theoretical semivariogram is a continuous function (model) fit to the data and can use different methods (e.g. gaussian)

Kriging is only using the x-y values of the data to spatially interpolate; not using any other data

```

---

# Part 1: Short Answer

## Question 1

Describe the difference in the use of Moran’s I and Ripley’s K (or L-function). (3 pts)

<span style="color: teal;">
Ripley’s K and the standardized L function quantify the aggregation of points on a landscape within a circular radius from a given point to determine if there is a significant difference between the observed pattern of points and a completely random distribution of points (Complete Spatial Randomness [CSR]). Moran’s I is used to quantify spatial dependence, or the similarity of a variable as a function of spatial location and/or geographic distance ([Fletcher & Fortin 2018](https://link.springer.com/book/10.1007/978-3-030-01989-1)). Moran’s I is a Pearson’s coefficient (range -1 to 1) for one variable against itself (autocorrelation) according to increasing distances among sampling locations.
</span>

## Question 2

Describe the difference between a correlogram and semivariogram. How do the scales compare? (3 pts)

<span style="color: teal;">
Correlograms and semivariograms are complementary approaches used to quantify spatial dependence. Correlograms plot a correlation coefficient such as Moran's I (autocorrelation of one variable) as a function of distance. Semivariograms plot semivariance (a "stabilized" measure of variance) as a function of distance. A correlation coefficient, used in a correlogram, is constrained between -1 (perfect negative correlation) and 1 (perfect positive correlation) with values close to 0 indicating weak correlation. Semivariance, used in a semivariogrm, is in the same units as the data (e.g. meters) with small values (close to 0) indicating strong spatial covariance and large values indicating less spatial covariance (i.e. weak or no spatial pattern).
</span>

## Question 3

Label the following semivariogram. (4 pts) 

![](../data/semiv.png){width=50%}

a. Nugget 
b. Sill
c. Partial Sill
d. Range

---

# Part 2: Cactus data

## Question 4: Correlogram (Moran’s I)

Generate a single plot containing the values from the two methods employed to generate correlograms (`pgirmess::correlog` and `ncf`, e.g., see figure 5.5a from Fletcher and Fortin). Also see the example of Canvas (Question 4 plot). Be sure to use 2/3rd maximum distance to restrict the values. Color the points based on p-value significance (e.g., red<0.05, black>0.05). At what distance(s) do you see spatial autocorrelation? Use ggplot to generate the graphic. (7 pts). 

```{r, results='hide'}
# load data
cactus_df <- read.csv('../data/cactus_matrix.csv', header=T)
#  Computes Moran's coefficients on distance classes
# pgirmess::correlog
  cactus_morans_temp <- pgirmess::correlog(
      coords = cactus_df %>% dplyr::select(x, y)
      , z = cactus_df$Height
      , method = "Moran"
      , nbclass = 14
      , alternative = "two.sided"
    ) %>%
    as.data.frame() %>% 
    dplyr::mutate(method = "pgirmess::correlog")
# ncf::correlog
  cactus_morans_full <- ncf::correlog(
      x = cactus_df$x
      , y = cactus_df$y
      , z = cactus_df$Height
      , increment = 5
      , resamp = 99
    )[1:5] %>% 
    as.data.frame() %>% 
    dplyr::mutate(method = "ncf::correlog") %>% 
    dplyr::rename(
      dist.class = mean.of.class
      , coef = correlation
      , p.value = p
    ) %>% 
    dplyr::select(names(cactus_morans_temp)) %>% 
    # combine with alternative method
    rbind(cactus_morans_temp) %>% 
    dplyr::mutate(
      signif = ordered(
        ifelse(p.value <= 0.05, 1, 0)
        , levels = c(0, 1)
        , labels = c("p-value>0.05", "p-value<0.05")
      )
    )
remove(cactus_morans_temp)
# plot
ggplot(
    data = cactus_morans_full %>% 
      dplyr::filter(dist.class <= max(cactus_morans_full$dist.class)*(2/3))
    , mapping = aes(x = dist.class, y = coef, group = method)
  ) +
  geom_hline(mapping = aes(yintercept = 0), color = "gray11", linetype = "dashed") +
  geom_line(color = "gray33", size = 1.2) +
  geom_point(mapping = aes(color = signif, shape = method), size = 2.5) +
  scale_color_manual(values = c("black", "red")) +
  labs(
    subtitle = "<span>
        <span style='color:red;'><b><i>red</i></b></span> = p-value<0.05 | 
        <span style='color:black;'><b><i>black</i></b></span> = p-value>0.05
        </span>"
    , y = "Moran's I"
    , x = "Distance (m)"
  ) +
  theme_bw() +
  theme(
    plot.subtitle = ggtext::element_markdown(size = 10)
    , legend.position = c(0.5, 0.93)
    , legend.direction = "horizontal"
    , legend.title = element_blank()
  ) + 
  guides(color = "none")

```

## Question 5: Semivariogram

Examine the empirical semivariogram created using gstat. Estimate the nugget, sill, and range. (3 pts) 

```{r}

```

## Question 6

Do you see any cause for concern regarding anisotropy? (3 pts)

```{r}

```


## Question 7

Plot the empirical and spherical theoretical semivariogram (through gstat). Add three colored lines to denote the nugget (blue), sill (green), and range (red). See example on Canvas. (6 pts)

Hint: the variogramLine() function is useful in extracting the theoretical values. 

```{r}
#Use the following code to form the base of your plot:
#ggplot()+
#geom_point(data=emp.gstat, aes(x=dist, y=gamma, size=np))
```


## Question 8 

Contrast the use of inverse distance weighting interpolation and kriging (using either spherical or exponential). Which method yields a better interpolation? A visual assessment is fine at this stage. (4 pts)

```{r}

```

---

# Part 3: Elevation Data

## Question 9

Use the code on Lines 244 to 276 to download elevation data and prepare the raster for the following kriging exercise. First, crop the extent and aggregate with the supplied code. Next, take a random selection of 500 points from the elevation surface. Using the code and knowledge gained through this lab, use kriging to interpolate elevation across the landscape using the 500 randomly selected points. (17 pts)

### part a)

What model fits best to the empirical variogram? Which did you try? 

### part b)

Provide the correlation between your best kriged model predictions and the known elevation. 

### part c)

Does your model perform better than inverse distance weighting? Provide the correlation between inverse distance weighting predictions and the known elevation. 

### part d)	

Make a four-panel plot that includes the randomly sampled points (shaded by elevation) and raster elevations from kriging, inverse distance weighting, and the truth. See example on Canvas. Use ggplot to generate the graphic. 

```{r}
#download elevation tif
#change the directory as needed
#srtm <- rast("/Users/kylehorton/Desktop/ECOL_620/Course_materials/Week5/Lab5/lab_5/data_for_lab5/srtm_15_05.tif")
#e <- ext(-107.5, -107, 37.5, 38)
#srtm=crop(srtm, e)
#plot(srtm)
#aggregate to reduce computation
#srtm = aggregate(srtm, fact=10, fun=mean) #mean value
#plot(srtm)
```


```{r}
#extract 500 points of elevation, randomly drawn
#set.seed(2020)
#srtm_pts=as.data.frame(spatSample(srtm, 500,method="random", xy=T))
#colnames(srtm_pts)[3]="elevation"
#head(srtm_pts)
#plot(srtm)
#plot(srtm_pts$x,srtm_pts$y)
```


```{r}
#Create grid with intervals of 0.008333333 degree)
#ext(srtm)
#res(srtm)
#e <- ext(srtm)
#new.grid<- rast(e, resolution=res(srtm), val=1)
#new.grid=as.data.frame(new.grid, xy=TRUE)
#new.grid=new.grid[,1:2]
```


 
